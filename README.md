# Desingn-Patterns
# Singleton(單例模式): 保證一個類別只會產生一個物件，而且要提供存取該物件的統一方法
# Simple Factory(簡單工廠模式): 定義一個簡單工廠，傳入不同的參數取得不同的類別物件
# Factory(工廠模式): 提供一個工廠介面，將產生實體的程式碼交由子類別各自實現
# AbstractFactory(抽象工廠模式): 用一個工廠介面來產生一系列相關的物件，但實際建立些物件由實作工廠的子類別來實現
# Strategy(策略模式): 將各種可以互換的演算法(策略)包裝成一個類別
# Decorator(裝飾者模式): 動態的將功能附加在物件上 
# Observer(觀察者模式): 處理一個物件對應多個物件之間的連動關係 
# Command(命令模式): 將各種請求(命令 Command)封裝成一個物件
# Adapter(轉接器模式): 將一個介面轉換成另外一個介面，讓原本與客戶端不能相容的介面可以正常工作
# Facade(表像(外觀)模式): 用一個介面包裝各個子系統，由介面與客戶端做溝通
# Template(樣版模式): 定義一套演算法的架構，但是細節可以延遲到子類別再決定
# Composite(合成模式): 處理樹狀結構的資料
# State(狀態模式): 將物件的狀態封裝成類別，讓此物件隨著狀態改變時能有不同的行為
# Proxy(代理模式): 為一個物件提供代理物件
# Builder(建造者模式): 將一個由各種組件組合的複查產品建造過程封
# Chain Of Responsibility(責任鏈模式): 讓不同的物件有機會能處理同一個請求
# Interpreter(解譯器模式): 定義一個語言與其文法，使用一個解譯器來表示這個語言的敘述
# Mediator(中介者模式): 當有多個物件之間有交互作用，使用一個中介物件來負責這些物件的交互以降低這些物件之間的偶合
# Prototype(原型模式): 複製一個物件而不是重新創建一個
# Bridge(橋梁模式): 將抽象介面與實作類別切開，使兩者可以各自變化而不影響彼此
# Memento(備忘錄模式): 將一個物件的內部狀態儲存在另外一個備忘錄物件中，備忘錄物件可以用來還原物件狀態
