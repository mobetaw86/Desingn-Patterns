# Desingn-Patterns
# Singleton(單例模式): 保證一個類別只會產生一個物件，而且要提供存取該物件的統一方法
# Simple Factory(簡單工廠模式): 定義一個簡單工廠，傳入不同的參數取得不同的類別物件
# Factory(工廠模式): 提供一個工廠介面，將產生實體的程式碼交由子類別各自實現
# AbstractFactory(抽象工廠模式): 用一個工廠介面來產生一系列相關的物件，但實際建立些物件由實作工廠的子類別來實現
# Strategy(策略模式): 將各種可以互換的演算法(策略)包裝成一個類別
# Decorator(裝飾者模式): 動態的將功能附加在物件上 
# Observer(觀察者模式): 處理一個物件對應多個物件之間的連動關係 
# Command(命令模式): 將各種請求(命令 Command)封裝成一個物件
# Adapter(轉接器模式): 將一個介面轉換成另外一個介面，讓原本與客戶端不能相容的介面可以正常工作
# Facade(表像(外觀)模式): 用一個介面包裝各個子系統，由介面與客戶端做溝通
# Template(樣版模式): 定義一套演算法的架構，但是細節可以延遲到子類別再決定
# Composite(合成模式): 處理樹狀結構的資料
# State(狀態模式): 將物件的狀態封裝成類別，讓此物件隨著狀態改變時能有不同的行為
